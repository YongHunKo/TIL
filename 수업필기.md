# 자바 시작하기
## 변수
> 하나의 값을 저장할 수 있는 저장 공간
### 자료형
int 정수형   
float 실수형   
double 실수형   
String 문자열

### 변수명 작성 규칙
- 첫 글자는 반드시 문자이거나 _ $로 시작
- 첫 글자에는 숫자를 사용할 수 없음
- 특수 문자는 사용할 수 없음
- 두단어 조합시 두번째 단어의 첫 글자를 대문자로
```java
public class VariableExam{
    public static void main(String[] args){
        int variable01 = 15;

        if(variable01 > 10){
            int variable02 = variable01 -10;
        }//Varialbe02는 여기까지만 의미
        int variable03 = variable02 + variable01+ 5; //variable02는 메모리에서 사라져 없으므로 에러
    }
}
```
### 강제 형변환(Casting)
> 형병환 연산자를 사용해 데이터 타입을 강제로 변환 하는 연산
### 문자열 형변환
>문자열은 어떤 자료형과 묶으면 무조건 문자열

- 기본 자료형을 문자열이면 항상 문자열이 됨
  - `1+"3" => "1 + 3"`
  - `"가"+7 => 가7`
- 문자열을 일반 자료형으로
    - 정수 : Integer.parseInt("")
    - 실수 : Double.parseDouble("")
    - 실수 : Float.parseFloat("")
## 키보드로부터 입력받기
### 데이터 입력
> Scanner 클래스 사용
> import하여 컴파일러에게 Scanner클래스 있는 곳 알려줌
### 데이터 입력 메소드
- next() : 문자열 사용자가 입력한 문자열 값
- nextLine() : 문자열 사용자 입력한 문자열의 값, 공백도 값으로 취급
- nextInt() : 정수형
```java
Scanner scan = new Scanner(System.in);//키보드로 부터 입력 받겠다는 객체 생성
```
## 제어문
### 조건문
```java
if(조건식){
    참일 때 실행할 문장}

if(조건식){
    참일 때 실행할 문장
    }else{
        거짓일 때 실행할 문장
        }

switch(변수){
    case 값1 : 실행할 문장 
    break;
    ...동 문장 반복 후 마지막에 
    default : 위의 값이 다 아닐때 실행할 문장 break;
}
```
### 반복문
```java
for(초기식; 조건식; 증감식){

}

for(int i=0; i.length<임의값; i++){

}

while (조건식){
    조건이 참일 때 반복할 문장
    }
//boolean함수 true를 조건식에 많이 넣기도함
//빠져나올때 false값을 주거나 break로 나옴
```

### 배열
> 동일한 자료형을 묶어 저장하는 참조 자료형   
> 여러 개의 값을 저장할 수 있는 공간   
> 선언시 어떤 자료형을 저장하는지 나타내야함   
> 선언시 반드시 크기를 설정
- 배열 객체 생성 및 선언
  ```java
  자료형[] 변수명 = new 자료형[크기];

  int[] arr = new int[3];
  // 크기가 3인 정수형 배열
  
  int[] arr = new int[]{10, 20, 30, 40}
  //또는
  int[] arr = {10, 20, 30, 40}
  ```

### 클래스
  > 설계도, 틀 의 역할
- 객체 지향 프로그래밍
    - 만드려고하는 완성품인 객체를 모델링하고, 집합관계에 있는 부품객체와 사용관계에 있는 객체를 하나씩 설계한 후 조립하는 방식으로 프로그램을 개발하는 기법
    - 특징
      - 캡슐화 : 정보은닉
      - 상속 : 재사용성
      - 다형성
- 클래스의 구성요소
    - 클래스 멤버 : 필드, 메소드
    - 생성자
- 객체를 생성하는 단계
    1. 클래스를 만든다(설계도, 틀)
    2. 객체 생성
    3. 객체 사용
### 접근제어자(modifier)
- public : 모든 클래스에서 사용가능
- protected : 같은 패키지에 있는 클래스에서는 모두 사용가능  
다른 패키지는 자식 클래스에서만 사용가능
- default : 접근제어자가 생략되면 모두 디폴트   
다른 패키지에서는 사용할 수 없음
- private : 같은 클래스 안에서만 자유롭게 사용할 수 있음   
  외부에서 사용하려면 getter, setter 사용해야함
### 메소드
> 객체의 동작에 해당하는 중괄호 { }블록
- 고려할 사항
  - 리턴되는 값이 없으면 void
  - 리턴값이 있으면 int String, double...)
  - 외부에서 호출하는 경우 : 참조 객체를 만들어 놓고 호출
    - 해당클래스 객체명 = new 해당클래스
    - 객체명.메소드 이런형식
  - 내부에서 호출하는 경우 : 메소드 이름으로 바로 호출
### 상속(Inher)
> 기존의 클래스를 재사용하여 새로운 클래스를 작성
```java
public class 자식클래스 extends 부모클래스 {

}//로 구성
```
- 자바는 다중상속 X
- 상속 관계 : IS - A
- 소유 관계 : HAS - A
### 오버라이딩(Overriding)
> 물려 받은 부모메소드를 자식 클래스에 맞도록 자시기에서 수정하는 것 (재정의)
- 규칙
    - 부모클래스의 메소드와 동일한 시그니처를 사용
    - 반환타입까지 동일해야 함
    - 부모 클래스의 메소드보다 접근범위를 좁게 할 수 없다.
- 불가능한 경우
    - private 메소드 : 부모클래스의 멤버가 private이면 자식클래스에 상속X
    - static 메소드
    - final 메소드 : 더 이상 수정 불가
### 다형성
> 1개의 객체를 여러가지 모양으로 표현할 수 있는 특성
1. 객체의 타입변환
  - 모든 객체를 타입변환 할 수 있는 것이 아니라 상속 관계일 때만 가능
2. 자동 타입 변환
   - 자식 클래스를 부모 클래스로 타입 변환할 수 있음
   - 자식은 부모타입으로 타입변환 가능 -> 업캐스팅
3. 강제 타입 변환
   - 부모타입 객체는 자식타입으로 변할 수 없다
   - **자식 객체지만 부모 타입 변수가 참조하고 있다면 자식 타입으로 변환 가능**
4. 타입 변환 가능 확인
   - `instance of`
   - 변수가 타입변환 할 수 있으면 true
### 추상클래스
> 추상메소드를 포함한 클래스
> 본체가 정의 되어 있지 않은 메소드
> ```java
> abstract void showInfo();
> //중괄호가 없어야함
> 접근제한자 abstract class 클래스명 {
> 미완성된 추상메소드
> }
> ```
- 상속을 통해 자식클래스에서 추상메소드를 오버로딩해서 완성
- 필요성
  - 부모의 일반메소드를 상속받은 자식은 재정의할 수도 있고 안할 수도 있다.
  - 그러나 추상메소드를 상속받은 자식은 반드시 재정의해야만 객체를 생성할 수 있다.
  - 약간 부모의 빚, 유산에 의한 상속세 지불 같은거?
  - 재정의를 놓치고 지나칠 수도 있어 크나큰 오류를 만들어 낼 수 있다. (자식이 반드시 재정의 했다는 보장을 할 수 없다)
  - 그러나 추상메소드는 자식이 재정의 하지 않으면 에러발생, 반드시 재정의 필요
- 특징
  - 추상클래스 자체로는 객체 생성불가
  - 미완성메소드를 포함하므로 heap메모리에 올릴 수 없기 때문
### 인터페이스
> 추상클래스를 심화시킨 특수한 형태
> 추상클래스와 인터페이스를 구분할 수 있어야함
> - 전부 추상이냐 아니냐의 차이
- 정의
  - 모든 필드가 `public static final`로 정의
  - 모든 메소드가 `public abstract`로 정의
- 구현(implement)를 사용
- 다중 구현이 가능
```java
interface A {...}
interface B {...}
interface C {...}
class D {...}
class E {...}
//가능한 경우
class D implements A { }
class D implements A, B { }
class D implements A, B, C { }

//불가능한 경우
class D extends D,E { }
class D extends A, B, C { }

//조건적 가능
public class Class D implements A { }
public interface A extends B { }

// 인터끼리는 구현 불가
public interface A implements B { }
```
### 예외(Exception)
> 예외와 에러의 차이   
> 예외는 연산오류, 포맷오류 등 상황에 따라 개발자가 해결 가능한 오류   
> 에러는 jvm자체의 오류로 개발자가 해결할 수 없음
- 일반예외 : 컴파일 전 빨간밑줄
- 실행예외 : run을 돌리면 나오는 예외
- 예외처리 : 예외가 뜨면 try-catch로 예외를 처리하고 계속 실행함
  ```java
  try { 예외 발생 가능 코드
  } catch (예외클래스이름 e){
    해당 예외가 발생할 경우 처리할 코드
  } finally { 예외 여부와 상관없이 무조건 실행하는 코드
  }
  ```
### 예외 떠넘기기(throws)
> 예외처리를 자신이 호출된 지점으로 떠넘긴다   
> 전가 받은 상위 위치에서 처리

- 예제를 살펴봐야 할거 같음

### 날짜/시간/표시형식
> 주로 `Date`와 `Calendar`를 사용하지만 Date는 **deprecated** 중

- Calendar클래스는 달력정보를 제공하는 클래스
- 지역, 문화에 따라 달력을 표시하는 방식이 다르기 때문에 **추상클래스**
- `Calendar now = Calendar.getInstance();`
```java
  public class CalendarTest{
    Calendar calDate = Calendar.getInstance();

    System.out.println(CalDate);//결과값이 사람말이 아님
    
    System.out.println(CalDate.get(Calendar.YEAR)+"년");//과 같은 방식으로 월, 일, 시 까지 불러올 수 있음
  }
  ```
- 규칙성 있는 숫자표시를 만들고 싶을 땐 `DecimalFomat`사용
```java
DecimalFormat df01 = new DecimalFormat("#,###");
System.out.println(df01.format(1234567));//1,234,567처럼 천단위로 끊는 규칙성을 표시해줌
DecimalFormat df02 = new DecimalFormat("#,###.00");//천단위 구분기호+소수점둘째자리(반올림처리)
```
### 제네릭(Generic)
> 클래스 내에서 사용되는 타입을 클래스가 정의할 때가 아닌 **객체를 생성할 때 정의**하겠다는 의미

- 클래스와 인터페이스 사용
- <>내부에 매개변수를 표시
- 영대문자면 어떤 것이든 사용가능
- 타입매개변수
  - 일반타입  T type
  - 원소      E element
  - 키        K key
  - 숫자      N number
  - 값        V value
### CompareTo(Object obl)
- 값을 비교하는 메소드
- 비교할 값이 매개값으로 고정값보다 크면 1, 작으면 -1, 같으면 0을 반환함
- 리턴타입은 int이다
### Thread
> 쓰레드는 cpu를 사용하는 최소단위   
> 단일 쓰레드면 2개의 작업을 처리할 때 순차적으로 처리   
> 멀티 쓰레드면 병렬처리

- 생성방법
  1. Thread클래스의 run()메소드를 오버라이딩
  2. Runnable interface 구현(추상메소드인 run()메소드를 구현)
- 실행방법
   ```java
   //클래스 만들기 - Thread클래스를 상속받아서 run()메소드를 재정의
   class MyWorkThread extends Thread{
    @Override
    public void run(){
      쓰레드 작업을 할 내용
    }
   }
   //객체 생성
   Thread myThread = new MyWorkThread();
   또는
   MyWorkThread myThread = new MyWorkThread();
   //실행
   myThread.start();
   ```
### Set 인터페이스
> 집합의 개념과 비슷하다
> 인덱스가 없고, 중복 저장이 불가능하다
1. HashSet
   - 입력 순서와 출력 순서는 동일하지 않을 수 있음   
   - 중복을 허용하지 않아서 hasCode(), equals()로 재정의
   - hasCode()->같다-->equals()-->true = 동일객체
   - 두 과정 중 하나라도 다르면 다른객체
2. TreeSet
    - 입력한 순서와 관계없이 크기순으로 출력(오름차순)
    - set의 기본 기능 + 검색/정렬 기능 추가
    - 저장 데이터는 반드시 대소비교가 가능해야함(오름차순이므로)
3. CompareTo(T t)
    - 상기 기술
### Map 계열 컬렉션 클래스
- 주로 검색용 자료구조
- 도서검색 물품검색에 탁월
- Key와 Value의 쌍으로 구성
- Key는 변경 불가, Value는 변경가능
- 인덱스가 없음

# MySQL시작하기