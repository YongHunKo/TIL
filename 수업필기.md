# 자바 시작하기
## 변수
> 하나의 값을 저장할 수 있는 저장 공간
### 자료형
int 정수형   
float 실수형   
double 실수형   
String 문자열

### 변수명 작성 규칙
- 첫 글자는 반드시 문자이거나 _ $로 시작
- 첫 글자에는 숫자를 사용할 수 없음
- 특수 문자는 사용할 수 없음
- 두단어 조합시 두번째 단어의 첫 글자를 대문자로
```java
public class VariableExam{
    public static void main(String[] args){
        int variable01 = 15;

        if(variable01 > 10){
            int variable02 = variable01 -10;
        }//Varialbe02는 여기까지만 의미
        int variable03 = variable02 + variable01+ 5; //variable02는 메모리에서 사라져 없으므로 에러
    }
}
```
### 강제 형변환(Casting)
> 형병환 연산자를 사용해 데이터 타입을 강제로 변환 하는 연산
### 문자열 형변환
>문자열은 어떤 자료형과 묶으면 무조건 문자열

- 기본 자료형을 문자열이면 항상 문자열이 됨
  - `1+"3" => "1 + 3"`
  - `"가"+7 => 가7`
- 문자열을 일반 자료형으로
    - 정수 : Integer.parseInt("")
    - 실수 : Double.parseDouble("")
    - 실수 : Float.parseFloat("")
## 키보드로부터 입력받기
### 데이터 입력
> Scanner 클래스 사용
> import하여 컴파일러에게 Scanner클래스 있는 곳 알려줌
### 데이터 입력 메소드
- next() : 문자열 사용자가 입력한 문자열 값
- nextLine() : 문자열 사용자 입력한 문자열의 값, 공백도 값으로 취급
- nextInt() : 정수형
```java
Scanner scan = new Scanner(System.in);//키보드로 부터 입력 받겠다는 객체 생성
```
## 제어문
### 조건문
```java
if(조건식){
    참일 때 실행할 문장}

if(조건식){
    참일 때 실행할 문장
    }else{
        거짓일 때 실행할 문장
        }

switch(변수){
    case 값1 : 실행할 문장 
    break;
    ...동 문장 반복 후 마지막에 
    default : 위의 값이 다 아닐때 실행할 문장 break;
}
```
### 반복문
```java
for(초기식; 조건식; 증감식){

}

for(int i=0; i.length<임의값; i++){

}

while (조건식){
    조건이 참일 때 반복할 문장
    }
//boolean함수 true를 조건식에 많이 넣기도함
//빠져나올때 false값을 주거나 break로 나옴
```

### 배열
> 동일한 자료형을 묶어 저장하는 참조 자료형   
> 여러 개의 값을 저장할 수 있는 공간   
> 선언시 어떤 자료형을 저장하는지 나타내야함   
> 선언시 반드시 크기를 설정
- 배열 객체 생성 및 선언
  ```java
  자료형[] 변수명 = new 자료형[크기];

  int[] arr = new int[3];
  // 크기가 3인 정수형 배열
  
  int[] arr = new int[]{10, 20, 30, 40}
  //또는
  int[] arr = {10, 20, 30, 40}
  ```

### 클래스
  > 설계도, 틀 의 역할
- 객체 지향 프로그래밍
    - 만드려고하는 완성품인 객체를 모델링하고, 집합관계에 있는 부품객체와 사용관계에 있는 객체를 하나씩 설계한 후 조립하는 방식으로 프로그램을 개발하는 기법
    - 특징
      - 캡슐화 : 정보은닉
      - 상속 : 재사용성
      - 다형성
- 클래스의 구성요소
    - 클래스 멤버 : 필드, 메소드
    - 생성자
- 객체를 생성하는 단계
    1. 클래스를 만든다(설계도, 틀)
    2. 객체 생성
    3. 객체 사용
### 접근제어자(modifier)
- public : 모든 클래스에서 사용가능
- protected : 같은 패키지에 있는 클래스에서는 모두 사용가능  
다른 패키지는 자식 클래스에서만 사용가능
- default : 접근제어자가 생략되면 모두 디폴트   
다른 패키지에서는 사용할 수 없음
- private : 같은 클래스 안에서만 자유롭게 사용할 수 있음   
  외부에서 사용하려면 getter, setter 사용해야함
### 메소드
> 객체의 동작에 해당하는 중괄호 { }블록
- 고려할 사항
  - 리턴되는 값이 없으면 void
  - 리턴값이 있으면 int String, double...)
  - 외부에서 호출하는 경우 : 참조 객체를 만들어 놓고 호출
    - 해당클래스 객체명 = new 해당클래스
    - 객체명.메소드 이런형식
  - 내부에서 호출하는 경우 : 메소드 이름으로 바로 호출
### 상속(Inher)
> 기존의 클래스를 재사용하여 새로운 클래스를 작성
```java
public class 자식클래스 extends 부모클래스 {

}//로 구성
```
- 자바는 다중상속 X
- 상속 관계 : IS - A
- 소유 관계 : HAS - A
### 오버라이딩(Overriding)
> 물려 받은 부모메소드를 자식 클래스에 맞도록 자시기에서 수정하는 것 (재정의)
- 규칙
    - 부모클래스의 메소드와 동일한 시그니처를 사용
    - 반환타입까지 동일해야 함
    - 부모 클래스의 메소드보다 접근범위를 좁게 할 수 없다.
- 불가능한 경우
    - private 메소드 : 부모클래스의 멤버가 private이면 자식클래스에 상속X
    - static 메소드
    - final 메소드 : 더 이상 수정 불가
### 다형성
> 1개의 객체를 여러가지 모양으로 표현할 수 있는 특성
1. 객체의 타입변환
  - 모든 객체를 타입변환 할 수 있는 것이 아니라 상속 관계일 때만 가능
2. 자동 타입 변환
   - 자식 클래스를 부모 클래스로 타입 변환할 수 있음
   - 자식은 부모타입으로 타입변환 가능 -> 업캐스팅
3. 강제 타입 변환
   - 부모타입 객체는 자식타입으로 변할 수 없다
   - **자식 객체지만 부모 타입 변수가 참조하고 있다면 자식 타입으로 변환 가능**
4. 타입 변환 가능 확인
   - `instance of`
   - 변수가 타입변환 할 수 있으면 true
### 추상클래스
> 추상메소드를 포함한 클래스
> 본체가 정의 되어 있지 않은 메소드
> ```java
> abstract void showInfo();
> //중괄호가 없어야함
> 접근제한자 abstract class 클래스명 {
> 미완성된 추상메소드
> }
> ```
- 상속을 통해 자식클래스에서 추상메소드를 오버로딩해서 완성
- 필요성
  - 부모의 일반메소드를 상속받은 자식은 재정의할 수도 있고 안할 수도 있다.
  - 그러나 추상메소드를 상속받은 자식은 반드시 재정의해야만 객체를 생성할 수 있다.
  - 약간 부모의 빚, 유산에 의한 상속세 지불 같은거?
  - 재정의를 놓치고 지나칠 수도 있어 크나큰 오류를 만들어 낼 수 있다. (자식이 반드시 재정의 했다는 보장을 할 수 없다)
  - 그러나 추상메소드는 자식이 재정의 하지 않으면 에러발생, 반드시 재정의 필요
- 특징
  - 추상클래스 자체로는 객체 생성불가
  - 미완성메소드를 포함하므로 heap메모리에 올릴 수 없기 때문
### 인터페이스
> 추상클래스를 심화시킨 특수한 형태
> 추상클래스와 인터페이스를 구분할 수 있어야함
> - 전부 추상이냐 아니냐의 차이
- 정의
  - 모든 필드가 `public static final`로 정의
  - 모든 메소드가 `public abstract`로 정의
- 구현(implement)를 사용
- 다중 구현이 가능
```java
interface A {...}
interface B {...}
interface C {...}
class D {...}
class E {...}
//가능한 경우
class D implements A { }
class D implements A, B { }
class D implements A, B, C { }

//불가능한 경우
class D extends D,E { }
class D extends A, B, C { }

//조건적 가능
public class Class D implements A { }
public interface A extends B { }

// 인터끼리는 구현 불가
public interface A implements B { }
```
### 예외(Exception)
> 예외와 에러의 차이   
> 예외는 연산오류, 포맷오류 등 상황에 따라 개발자가 해결 가능한 오류   
> 에러는 jvm자체의 오류로 개발자가 해결할 수 없음
- 일반예외 : 컴파일 전 빨간밑줄
- 실행예외 : run을 돌리면 나오는 예외
- 예외처리 : 예외가 뜨면 try-catch로 예외를 처리하고 계속 실행함
  ```java
  try { 예외 발생 가능 코드
  } catch (예외클래스이름 e){
    해당 예외가 발생할 경우 처리할 코드
  } finally { 예외 여부와 상관없이 무조건 실행하는 코드
  }
  ```
### 예외 떠넘기기(throws)
> 예외처리를 자신이 호출된 지점으로 떠넘긴다   
> 전가 받은 상위 위치에서 처리

- 예제를 살펴봐야 할거 같음

### 날짜/시간/표시형식
> 주로 `Date`와 `Calendar`를 사용하지만 Date는 **deprecated** 중

- Calendar클래스는 달력정보를 제공하는 클래스
- 지역, 문화에 따라 달력을 표시하는 방식이 다르기 때문에 **추상클래스**
- `Calendar now = Calendar.getInstance();`
```java
  public class CalendarTest{
    Calendar calDate = Calendar.getInstance();

    System.out.println(CalDate);//결과값이 사람말이 아님
    
    System.out.println(CalDate.get(Calendar.YEAR)+"년");//과 같은 방식으로 월, 일, 시 까지 불러올 수 있음
  }
  ```
- 규칙성 있는 숫자표시를 만들고 싶을 땐 `DecimalFomat`사용
```java
DecimalFormat df01 = new DecimalFormat("#,###");
System.out.println(df01.format(1234567));//1,234,567처럼 천단위로 끊는 규칙성을 표시해줌
DecimalFormat df02 = new DecimalFormat("#,###.00");//천단위 구분기호+소수점둘째자리(반올림처리)
```
### 제네릭(Generic)
> 클래스 내에서 사용되는 타입을 클래스가 정의할 때가 아닌 **객체를 생성할 때 정의**하겠다는 의미

- 클래스와 인터페이스 사용
- <>내부에 매개변수를 표시
- 영대문자면 어떤 것이든 사용가능
- 타입매개변수
  - 일반타입  T type
  - 원소      E element
  - 키        K key
  - 숫자      N number
  - 값        V value
### CompareTo(Object obl)
- 값을 비교하는 메소드
- 비교할 값이 매개값으로 고정값보다 크면 1, 작으면 -1, 같으면 0을 반환함
- 리턴타입은 int이다
### Thread
> 쓰레드는 cpu를 사용하는 최소단위   
> 단일 쓰레드면 2개의 작업을 처리할 때 순차적으로 처리   
> 멀티 쓰레드면 병렬처리

- 생성방법
  1. Thread클래스의 run()메소드를 오버라이딩
  2. Runnable interface 구현(추상메소드인 run()메소드를 구현)
- 실행방법
   ```java
   //클래스 만들기 - Thread클래스를 상속받아서 run()메소드를 재정의
   class MyWorkThread extends Thread{
    @Override
    public void run(){
      쓰레드 작업을 할 내용
    }
   }
   //객체 생성
   Thread myThread = new MyWorkThread();
   또는
   MyWorkThread myThread = new MyWorkThread();
   //실행
   myThread.start();
   ```
### Set 인터페이스
> 집합의 개념과 비슷하다
> 인덱스가 없고, 중복 저장이 불가능하다
1. HashSet
   - 입력 순서와 출력 순서는 동일하지 않을 수 있음   
   - 중복을 허용하지 않아서 hasCode(), equals()로 재정의
   - hasCode()->같다-->equals()-->true = 동일객체
   - 두 과정 중 하나라도 다르면 다른객체
2. TreeSet
    - 입력한 순서와 관계없이 크기순으로 출력(오름차순)
    - set의 기본 기능 + 검색/정렬 기능 추가
    - 저장 데이터는 반드시 대소비교가 가능해야함(오름차순이므로)
3. CompareTo(T t)
    - 상기 기술
### Map 계열 컬렉션 클래스
- 주로 검색용 자료구조
- 도서검색 물품검색에 탁월
- Key와 Value의 쌍으로 구성
- Key는 변경 불가, Value는 변경가능
- 인덱스가 없음

# MySQL시작하기
## RDBMS
>DB(DataBase)는 데이터의 집합
>DBMS(DBManagementSystem)은 DB를 관리, 운영하는 역할을 함
### DB의 특징
  1. 무결성
    - 데이터는 **어떤 경로**를 통해 들어 왔던지 데이터의 오류는 없어야함
  2. 독립성
    - 데이터를 변경하거나 경로를 변경해도 기존에 작성된 프로그램에 **전혀 영향을 받지 않아야함**
  3. 보안
    - 데이터를 소유한 사람이나 접근 허가가 된 사람만 접근할 수 있어야함
  4. 데이터 중복의 최소화
    - 여러개 중복되어 저장되는 것을 방지
  5. 응용 프로그램 제작 및 수정이 쉬워짐
  6. 안정성 향상 
    - 백업, 복원기능을 이용하여 데이터가 깨지는 문제를 방지
### DBMS의 종류
  1. 계층형 DBMS
  2. 망형 DBMS
  3. **관계형 DBMS** = RDBMS
    - 데이터베이스는 테이블이라 불리는 최소 단위로 구성되어 있다. 그리고 테이블은 하나 이상의 열로 구성되어 있다.
    - 따라서 테이블이라는 구조가 RDBMS에서 가장 기본적이고 중요한 구성
    - 데이터를 효율적으로 저장하기 가능
    - 여러개의 테이블을 만들어 불필요한 공간낭비 줄이기 가능
    - 여러 테이블끼리 기본 키와 외래 키의 관계로 맺어줌
    - 업무가 변화되도 쉽게 변화에 순응할 수 있음
    - 시스템 자원을 많이 차지하여 시스템이 느려질 수 있음
    - 우리가 배우려는 MySQL도 여기에 속함
## SQL
> Structured Query Language
> ANSI 에서 이를 표준화함
### SQL 특징
1. 제작회사와 독립적
2. 이식성이 좋음
3. 표준이 계속 발전
4. 대화식 언어
   - Structured Query Language가 질의적 언어. 나와 컴퓨터 사이 대화
5. 분산형 클라이언트/서버 구조
### SQL 주요 문법
1. DDL(Data Definition Language)
    - DATABASE&TABLE 생성, 삭제, 변경
2. DML(Date Manuplate Language)
    - Date CRUD(Create, Read, Update, Delete)
3. DCL(Data Control Language)
>우리는 DDL DML을 중점적으로 공부할 예정

## MySQL
> 우리가 배울 볼펜 같은 도구
> 우리는 workbench와 cmd둘다 사용할줄 알아야함
### workbench의 사용
1. 편하다
2. 실행 시 루트를 통해 설치 할때 설정한 비밀번호를 입력하여 들어감
3. 기본적인 화면에 왼쪽 schemas칸을 주로 사용하고, MySQL의 내부 디렉토리를 보여주서 직관력이 좋음
4. 다른 프로그램들과 같이 명령창이 있어서 여기서 대화를 주고 받을 수 있음
5. 번개랑 커서번개랑 두개가 있음. 번개는 명령문 전체를 실행. 커서번개는 커서가 위치한 줄만 실행.
6. 주요 명령어
```SQL
SHOW database ; --생성된 데이터 베이를 보여줘. 없을시 empty
CREATE DATABASE database ; --데이터베이스를 만들어줘
DROP DATABASE database ; --데이터베이스를 비워줘, 예제를 보니 쓰레기값을 방지하기위해 초반에 데이터베이스를 드랍시키고 다시 생성하는거 같음, 없는 데이터베이스면 1008오류가 뜸
DROP DATABASE IF EXISTS database ; -- 데이터 베이스를 비워줘 만약에 있으면
USE database ; --해당 데이터베이스를 사용할거야 = 클릭이랑 똑같음
SELECT * FROM database ; --데이터베이스 안에 테이블에 저장된 걸 보여줘
DESC database ; --구조를 출력해줘, 테이블 값의 타입을 보여줌
```
7. 명령어 부분을 대문자로 써준다
8. 백업가능
### cmd의 사용
1. 기본적인건 workbench와 똑같다
2. cmd상에서는 workbench와 같이 UI가 없으므로 텍스트에 의존해야함
3. 주요 명령어
```cmd
\mysql -u root -p ; 
MySQL을 실행하고 root유저로 비밀번호를 쳐서 들어가겠다. 그리고 설치시 설정했던 루트비밀번호를 입력
\SOURCE database.sql ;
 해당 폴더의 해당sql파일을 열어준다
*주의* 해당 폴더까지 cd를 통해 이동해주고 해당 폴더에 들어가서 실행
주요 명령어는 벤치와 똑같다
```
4. 백업 불가능. 하지만 미리 sql파일로 저장된 걸 불러올 수 있음
### SELECT
> 할게 많다
> 기본적으로 내 스타일은 `SELECT * FROM emp;`를 베이스로 *을 지워 문제에 필요한 데이터를 먼저 보고 후에 이거에 맞춰서 작업하는 스타일
> 그래서 남들보다 첫줄이 일단 길다

1. 주요 명령어
    - `WHERE` = 조건이 ~인 자료를 찾아줘
    - `NULL`은 '='을 붙이는게 아니라 IS를 붙임