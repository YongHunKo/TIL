# day 1 ~5일차
> 사실 진짜 별거 없는 주였다
# day 6

```java
//1.classExam
package classExam;

public class Bus {
	//필드
	public int busNumber;
	public int passengerCount;
	public int money;
	
	//생성자
	public Bus(int busNumber) {
		this.busNumber = busNumber;
	}
	//메소드
	//버스의 수입 계산
	public void take(int money) {
		this.money +=money;
		passengerCount++;
	}
	public void showInfo() {
		System.out.println("버스"+ busNumber + "번의 승객은"+passengerCount+"명 이고, 수입은 "+money+"입니다.");
	}
}

package classExam;

public class Student {
	//버스비와 지하철비를 고정으로 두고
		//변동하는 학생들 수를 둘로 나눠
		//버스비*버스승객 , 지하철*지하철승객
		//그러면 버스회사 수입, 지하철 수입이 나온다
		//학생들은 돈을 지불했으니 가지고있는 돈에서 빠진다
	// 학생
	// 이름 : studentName
	// 학년 : grade
	// 돈 : money
	// 버스
	// 버스노선 : busNumber
	// 승객수 : passengerCount
	// 버스수입 : money
	// 지하철
	// 지하철노선 : lineNumber
	// 승객수 : passengerCount
	// 지하철수입 : money
	// 학생이 버스를 탄다, 지하철을 탄다
	
	//필드 : 접근제어자 자료형 필드명
	public String studentName;
	public int grade;
	public int money;
	
	//생성자 : 접근제어자 클래스명(){}
	//		 접근제어자 클래스명(매개변수,...){}
	//		 ~의 남은돈은 ~입니다 가 목적(학생입장)
	//		 ~번 버스,지하철 승객은 ~명이고, 수입은 ~이다
	//따라서 생성자파트에서는 이름, 금액이 필요
	public Student(String studentName, int grade, int money) {
		super();
		this.studentName = studentName;
		this.grade = grade;
		this.money = money;
	}
	//메소드 : 접근제어자 리턴타입 메서드명(){}
	//		 접근제어자 리턴타입 메서드명(매개변수,...){}
	// 학생이 버스를 선택한 경우
	public void takeBus(Bus bus) {//임의의 메소드명 작명
		//버스요금
		bus.take(1250);
		//남은 돈
		this.money -= 1250;
	}
	public void showInfo() {
		System.out.println(studentName + "의 남은 돈은"+ this.money + "입니다.");
	}
}

package classExam;

public class Sub {
	public int subNumber;
	public int passengerCount;
	public int money;
	
	public Sub(int subNumber) {
		this.subNumber = subNumber;
	}
	public void take(int money) {
		this.money +=money;
		passengerCount++;
	}
	public void showInfo() {
		System.out.println("지하철"+subNumber+"호선의 승객은"+passengerCount+"명 이고, 수입은"+money+"입니다.");
	}

}
```
- 6일차 예제1
- 지금 보면 쉬워보이는 예제이다 take값도 입력값으로 줘버리거나 할 수 있는데 강사님의 배려가 돋보인다
- 아직 이만큼이나 클래스를 잘 쪼개진 못한다
  
```java
package classMember;

public class Car {
	//필드(=멤버변수, 클래스 멤버변수, 인스턴스 변수)
       String company; // default String company; 디폴트가 생략된거임 그래서 다른패키지에 못씀
      public String model; //퍼블릭을 붙이니 쓸수있다
      private String color="노랑"; //같은 클래스에서만 쓸수있음
      int maxSpeed;
      
      public String getColor() {
    	  return color;
      }
      
      public void setColor(String color) {
    	  this.color = color;
      }
      //생성자
      public Car() {
    	  company = "현대";
          model = "아반떼";
          color = "yellow";
          maxSpeed = 250;
      }
      public Car(String company, String model, String color, int maxSpeed) {
    	  this.company = company;
    	  this.model = model;
    	  this.color = color;
    	  this.maxSpeed = maxSpeed;
      }
      
      //메소드
      
}

package classMember;

public class CarExan {

	public static void main(String[] args) {
		//객체 생성
		Car myCar = new Car();
		Car momCar = new Car("기아","k7","검정",350);
				
				//객체사용
	    System.out.println(myCar.company);
		System.out.println(myCar.getColor());
		System.out.println();
		
		System.out.println(momCar.company);
		System.out.println(momCar.getColor());
		
	}

}

package classMember;

public class ClassMember {
      // 설계도(클래스) -> 객체생성 -> 객체 사용
	  //1. 클래스( 필드, 생성자, 메소드 )
	  //학생 => 이름, 학년, 성적=> 필드
	String name = "홍길동"; // String name=null 지역변수일땐 이렇게
	int grade;   // grade=0 지역변수일땐 이렇게
	double score;
	  //학생 공부를 한다. => 메소드
	//기본 생성자
	  public ClassMember() { 
	
	  };
	  
	  //매개변수가 있는 생성자
	public ClassMember(String n, int g, double s) {
		name = n;
		grade = g;
		score = s;

	}

}

package classMember;

public class ClassMemberExam {

	public static void main(String[] args) {
		//2. 객체 생성하는 작업 = 붕어빵틀
		ClassMember mem = new ClassMember(); //붕어빵 틀에 다른 재료 넣는거
		ClassMember hong = new ClassMember();
		
System.out.println(mem.name);
System.out.println(hong.name);



	}

}

```

- 6일차 예제2,3번
- 아직 객체라는 것에 이해가 덜 되어있을 때 예제
- 1클래스에서 2클래스의 것을 사용하려할 때 1클래스에서    
- `A a = new A`형식으로 객체를 생성할 수 있다
- 약간 발렛파킹같은 개념
  - 호텔에 온 손님이 호텔에 고객명단을 작성하고 발렛을 맡겨서 주차하도록 사용하는
  - 기본적으로 오른쪽의 것을 왼쪽에 담는다

```java
package methoExam;
/*
 * 전원 켜기, 전원 끄기, 덧셈, 뺄셈, 곱셈, 나눗셈
 */
public class Calculator {
	//1.클래스(설계도) -> 객체생성 ->객체사용
	//클래스작성
	//필드
		
	//생성자
		
	//메소드
    //1. 전원 켜기
	public void powerOn() { //void : 결과를 리턴하지 않고 여기서 실행하고 끝낸다
		System.out.println("전원을 켭니다");
	}
	//2. 전원 끄기
	public void poweroff() {
		System.out.println("전원을 끕니다");
	}
	//3. 더하기 : 정수 두 개
	public int add(int num1, int num2) { //지역변수
		int result = num1 + num2;
		return result; //결과값을 가지고 자신을 호출한 곳으로 되돌아가라, 여기서 메소드를 빠져나감
					   //리턴 뒤의 값은 실행하지 않아 의미 없음
//		System.out.println("안녕");
	}
	//4. 나누기 : 정수 두 개
	public int division(int a, int b) {
		// a/b  b는 0이 아니다 체크
			return a/b;
	}
	
	public double avg(int x , int y) {
		double sum = add(x, y);
		double result = sum / 2;
		return result;
	}
	
}

package methoExam;

public class CalculatorExam {

	public static void main(String[] args) {
		//2.객체 생성
		Calculator cal = new Calculator();
		
		System.out.println(cal.add(5, 7));
		int re = cal.add(10, 20);
		System.out.println(re);
		
		System.out.println(cal.division(5, 7));
		
		System.out.println(cal.avg(4, 7));
//		System.out.println(cal.poweroff()); void는 프린트ln못씀
//		substract(3,2);
		
	}
//	public static int sbstuact(int x, int y) {
//		return x-y;

}
/*
 * 문제1) Printer 객체 생성
 * 		프린트 용지(numofPaper)
 * 
 * 		PrinterTest 실행클래스(메인)
 * 		프린터 용지 : 100장 주입 (초기값)
 * 		프린트 -> 70장
 * 			메소드 이용해서 처리
 * 		
 * 		출력)
 * 		70장 프린트
 *		남은 용지 : 30장
 *
 *용지가 부족?
 *초기 기본 용지는 아무나 변경하지 못하게 (numOfPaper ) ->private 처리
 *초기값은 생성자로 설정(100매)
 *
 * prtPaper 메소드
 * 출력할 때 남아 있는 용지가 없다면 용지가 없다고 알려줌
 * 남아 있는 용지보다 많은 출력을 요구하면 남아 있는 용지 만큼만 출력하고 부족한 용지 매수를 알려 줌
 * 출력한 후 남아 있는 용지 매수를 알려 줌
 * 
 * 실행 클래스에서는
 * <출력 형태>
 *2장 출력했습니다. 현재 98장 남아 있습니다.
 *
 *모두 출력하려면 용지가 xx매 부족합니다.
 *장만 출력합닌다.
 *용지가 없습니다
 */

package methoExam;

public class Printer {

		private int numOfPaper; 
		public Printer() {	}
		
		public Printer(int numOfPaper) { 
			this.numOfPaper = numOfPaper;
		}
		
		public void prtPaper(int amount) {
			if(numOfPaper==0) {
				System.out.println("�슜吏��뾾�쓬");
			}else if(numOfPaper <amount) {
				System.out.printf("%d留� 遺�議�",amount - numOfPaper);
			    System.out.println(numOfPaper + "�옣留� 異쒕젰");
			    numOfPaper = 0; 
				numOfPaper -= amount;
				System.out.println(amount + "�옣 異쒕젰");
				System.out.println("�쁽�옱" + numOfPaper + "�옣 �궓�쓬");
			}
		}
		
		
		public int getNumOfPaper() { 
			return numOfPaper;
		}
		public void setNumOfPaper(int numOfPaper) {
			
			this.numOfPaper = numOfPaper;
		}
	

}

package methoExam;

public class PrinterTest {

	public static void main(String[] args) {
//		int printNum = 70; 
		
		//객체 생성
		//Printer p = new Printer();
//		p.numOfPaper = 100; //외부에서 초기값 설정
//		p.prtPaper(printNum);
		
//		System.out.println("프린트 = "+ printNum);
//		System.out.println("남은 용지 = "+p.numOfPaper);
		//문제2
		Printer prt = new Printer(100);
		
		prt.prtPaper(5);
		prt.prtPaper(20);
		prt.prtPaper(10);
	}

}

```
- 6일차 예제4,5번
- 제일 응용 많이 가능한 계산기문제 + 22년 08월 25일 새벽을 괴롭힌 프린터 문제
- 중간에 한글이 깨져있지만 신경 안쓰고 보이는데로 해도 보임
- 계산기문제를 통해 `필드, 생성자, 메소드` 라는 구성을 인식시키는 계기가 됨
- **필드**는 초기조건 즉 우리가 마시는 공기처럼 밖에 꺼내져 있는 것
- **생성자**는 초기조건의 변수를 이용하겠다고 선언 즉 공기를 마시는 사람을 생성하는 것
- **메소드**는 우리가 실행클래스에서 쓸 도구를 만드는 작업
- 이 세가지가 조합되어 우리는 하나의 실행 클래스의 일부를 동작하게 할 수 있다.

# day 15
```java
package Exam;

public class Board {
    private String title;
    private String content;

    public Board(String title, String content) {
        this.title = title;
        this.content = content;
    }

    public String getTitle() {
        return title;
    }

    public String getContent() {
        return content;
    }
}
//기본적인 설계클래스

package Exam;
import java.util.ArrayList;
import java.util.List;

public class BoardDao {
    //여기서 해야하는 작업
    //제목1 - 내용1
    //제목2 - 내용2
    //제목3 - 내용3
    //형식은  실행에 만들어 졌음. 여기서 private로 지정된 title과 content 어레이리스트를 실행으로
    public List<Board> getBoardList() {
        List<Board> list = new ArrayList<Board>();
        list.add(new Board("제목1", "내용1"));
        list.add(new Board("제목2", "내용2"));
        list.add(new Board("제목3", "내용3"));
        return list;
    }
    //1.getBoardList라는 메소드를 만드는데 생성자는 Board에서 만들었고 이걸 배열로 나타내기위해 따로 List<Board>타입으로 나타냄
    //2.list에 arraylist를 담음
    //3.제네릭의 타입이 Board이므로 Board의 title, content를 따옴
    //4.따라서 리스트에 추가를 한다, 새로운 Board의 생성자 형식을 이용하여
    //5.리턴값은 리스트(객체)로 보내줘야한다
}
//제네릭+ArrayList를 사용한 메소드

package Exam;
import java.util.List;
public interface ListExample {
    public static void main(String[] args) {
        BoardDao dao = new BoardDao();
        List<Board> list = dao.getBoardList();
        for(Board board : list) {
            System.out.println(board.getTitle()+"-"+board.getContent());
        }
    }
    //6. BoardDao의 객체를 dao에 담는다
    //7. dao의 BoardList를 가져오는데 타입이 List<Board>이므로 담을 곳도 타입을 맞춰줌
    //8. 향상된 for문으로 list를 표현

}
//실행클래스
```
- 중간고사를 대비해서 미리 풀어보려 했는데 혼자서는 못품
- 메소드 클래스에서 title content를 프라이빗으로 잡고 하려고 했음. 불러왔어야했는데
- ArrayList에 대해 아직 잘 모르는거 같음
- 한번 더 해봄
```java
//설계클래스와 실행클래스는 중복이니 위 예제 참고
package Exam;

import java.util.ArrayList;
import java.util.List;

public class BoardDao {
	public List<Board> getBoardList(){//getBoardList라는 메소드를 생성하는데 타입이 스트링 인트 이런게 아니라 List<Board>라는 타입 Board는 다른 클래스에서 생성자를 미리 만듬
		List<Board> list = new ArrayList<Board>();
		list.add(new Board("제목1", "내용1"));
		
		return list;//여기서 나온 값은 list이니 list를 getBoardList를 호출하면 나오도록 저장
		
	}
}
//다시 해본 메소드 클래스
```
- 쪼끔은 이해될거같은 느낌의 제네릭+어레이리스트
- 몇개를 좀 더 찾아다 해봐야할 듯
- 모양은 어느정도 이해가 간다.
